<!DOCTYPE html>
<!--suppress ALL -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Processing Table :: </title>
    <script>
        const { ipcRenderer,remote } = require('electron'), { BrowserWindow, } = remote, currentWindow = remote.getCurrentWindow(),
            $ = require('jquery'), _ = require('lodash'), db = require('mysql'), path = require('path'), fs = require('fs'),
            limitRecords = 5000,
            executeQueryWindowConf = { width:300, height:300, show:false }, executeQueryWindowUrl = path.join(__dirname,'getQueryResult.html'),
            uploadActivityWindowConf = executeQueryWindowConf, uploadActivityWindowUrl = path.join(__dirname,'doUploadActivity.html'),
            updateDateWindowConf = executeQueryWindowConf, updateDateWindowUrl = path.join(__dirname,'updateDates.html')
            importActivityWindowConf = executeQueryWindowConf, importActivityWindowUrl = path.join(__dirname,'importActivity.html'),
            downloadActivityWindowConf = executeQueryWindowConf, downloadActivityWindowUrl = path.join(__dirname,'doDownloadActivity.html')
        ;
        let table,type,tblData,sync,record,primary_key,fields,mysqlParams,mysql,oneTime,mode,url,id,
            parentWindow, reCloseDelay = 2000, reCloseTimeOut = null, syncFile,fetchNext = { update_or_create:0,create:0,update:0 },
            executeQueryWindow, uploadActivityWindow, updateDateWindow, importActivityWindow, downloadActivityWindow,
            Activity = [], latestDates = { sync:null,record:null }, modeDateFieldMap = { update:'MODIFIED_DATE',create:'CREATED_DATE' };
    </script>
    <script>
        ipcRenderer.on('config',function(event,dataObj){
            table = dataObj.table; tblData = dataObj.tblData; syncFile = dataObj.syncFile;
            parentWindow = BrowserWindow.fromId(dataObj.parentWindowId)
            type = tblData[table].type; sync = tblData[table].sync; record = tblData[table].record; delay = tblData[table].delay; id = tblData[table].id; primary_key = tblData[table]['primary_key']; fields = tblData[table]["fields"];
            mysqlParams = dataObj.mysqlParams; setupMysqlConnection();
            $('title').append(table); oneTime = isOneTimeTable(); url = dataObj.url;
            initProcess()
        });

        ipcRenderer.on('log',function (event,text){ log(text) });
        ipcRenderer.on('query-result',function (event,fn,args){ destroyWindow(executeQueryWindow); window[fn].apply(window[fn],args); });
        ipcRenderer.on('failed-upload-activity',function (){ destroyWindow(uploadActivityWindow); log('Skipping..'); repeatedProcess(); });
        ipcRenderer.on('done-upload-activity',function (event,response){ destroyWindow(uploadActivityWindow); postUploadActivities(response); });
        ipcRenderer.on('update-date-success',function (event,response){ destroyWindow(updateDateWindow); writeTableDates(); });
        ipcRenderer.on('update-date-failed',function (){ log('Skipping..'); destroyWindow(updateDateWindow); repeatedProcess(); });
        ipcRenderer.on('failed-download-activity',function (){ destroyWindow(downloadActivityWindow); log('Skipping..'); completeProcessingTable(); });
        ipcRenderer.on('done-download-activity',function (event,response){ destroyWindow(downloadActivityWindow); postDownloadActivities(response); });
        ipcRenderer.on('done-import-activity',function (event,data){ destroyWindow(importActivityWindow); postImportActivities.apply(this,data); });

        function send(channel,args){ parentWindow.send(channel,args); }
        function log(text,fn){ send('log',`${table}(${type}) :: ${text}`); if(fn) window[fn].call(); }
        function completeProcessingTable(){
            if(_.some([executeQueryWindow,uploadActivityWindow,updateDateWindow,importActivityWindow,downloadActivityWindow],(win) => !_.isNil(win))){
                clearTimeout(reCloseTimeOut); reCloseTimeOut = setTimeout(completeProcessingTable,reCloseDelay);
            } else { log('Finished..'); send('complete-process-table',[table,type]); } }
    </script>
    <script>
        function isOneTimeTable(){ return (!_.includes(fields,'CREATED_DATE') && !_.includes(fields,'MODIFIED_DATE')); }
        function getDateTime(){
            let d = new Date();
            return [[d.getFullYear(),to2(d.getMonth()+1),to2(d.getDate())].join('-'),[to2(d.getHours()),to2(d.getMinutes()),to2(d.getSeconds())].join(':')].join(' ')
        }
        function to2(t){ return _.padStart(t,2,0)}
        function getMaxOfDateField(collection,field){
            let dateObject = _.mapKeys(_.map(collection,field),dText => new Date(dText).getTime());
            return _.get(dateObject,_.max(_.keys(dateObject)))
        }
        function isJsonString(string){
            try{ JSON.parse(string) } catch(e) { return false; }
            return true;
        }
        function getJsonFromString(input) {
            return (_.isString(input) && isJsonString(input)) ? JSON.parse(input) : ( _.isPlainObject(input) ? input : [])
        }
    </script>
    <script>
        function setupMysqlConnection(){ mysql = db.createConnection(mysqlParams); }
        function getSyncCreatedQuery(limit){ return mysql.format("SELECT * FROM ?? WHERE ?? > ? ORDER BY ?? ASC LIMIT ?,?",[table,'CREATED_DATE',created,'CREATED_DATE',limit,limitRecords]); }
        function getSyncUpdatedQuery(limit){ return mysql.format("SELECT * FROM ?? WHERE ?? > ? AND ?? <= ? ORDER BY ?? ASC LIMIT ?,?",[table,'MODIFIED_DATE',updated,'CREATED_DATE',created,'MODIFIED_DATE',limit,limitRecords]); }
        function getSyncAllQuery(limit){ return mysql.format("SELECT * FROM ?? LIMIT ?,?",[table,limit,limitRecords]); }
        function getUpSync(limit){ return mysql.format("SELECT * FROM ?? LIMIT ?,?",[table,limit,limitRecords]); }

        function update_or_create_RecordQuery(){ return mysql.format("SELECT * FROM ?? LIMIT ?,?",[table,fetchNext.update_or_create,limitRecords]) }
        function create_RecordQuery(datetime){ return mysql.format("SELECT * FROM ?? WHERE ?? > ? ORDER BY ?? ASC LIMIT ?,?",[table,'CREATED_DATE',datetime,'CREATED_DATE',fetchNext.create,limitRecords]) }
        function update_RecordQuery(record,sync){ return mysql.format("SELECT * FROM ?? WHERE ?? <= ? AND ?? > ? ORDER BY ?? ASC LIMIT ?,?",[table,'CREATED_DATE',record,'MODIFIED_DATE',sync,'MODIFIED_DATE',fetchNext.update,limitRecords]) }
    </script>
    <script>
        function initProcess(){
            Activity = []; log('Processing');
            window[type+'SyncInit'].call();
        }
        function upSyncInit(){
            let queries = {};
            if(delay === 0 && oneTime) queries['update_or_create'] = update_or_create_RecordQuery();
            else if(!record) queries['update_or_create'] = update_or_create_RecordQuery();
            else {
                queries['create'] = create_RecordQuery(record);
                if(sync) queries['update'] = update_RecordQuery(record,sync);
            }
            loadExecuteQueryWindow(queries,'handleQueryResults');
        }
        function bothSyncInit(){
            return upSyncInit();
        }
        function downSyncInit(){
            loadDownloadActivityWindow();
        }
        function handleQueryResults(result){
            for(x in result){
                let mode = x, data = result[x];
                if(data === false) log(mode + ' :: Error!!')
                else if(data.length === 0) log(mode + ' :: No data');
                else {
                    fetchNext[mode] = (data.length >= limitRecords) ? (fetchNext[mode] + data.length) : 0
                    Activity.push(wrapActivity(data,mode));
                }
            }
            startProcessingActivity()
        }
        function startProcessingActivity(){
            if(!Activity || _.isEmpty(Activity)) return completeProcessingTable();
            log(`${Activity.length} activities found!!`);
            uploadActivityData(Activity);
        }
        function repeatedProcess() {
            if(type === 'down') return completeProcessingTable();
            let queries = {};
            Activity = []; log('Check for further records..');
            for(x in fetchNext){ if(fetchNext[x] !== 0) queries[x] = window[x+'_RecordQuery'].call(this,sync); }
            if(Object.keys(queries).length > 0) return loadExecuteQueryWindow(queries,'handleQueryResults');
            else return completeProcessingTable();
        }
    </script>
    <script>
        function oneTimeSyncQueryResult(error,rowsPack,fieldPack) {
            if(error) return log('Error while fetching data, skipping !!','startProcessingActivity')
            let result = JSON.parse(JSON.stringify(rowsPack)); if(!result.length) return log('No data','startProcessingActivity');
            log(`${result.length} records to mode update_or_create`); Activity.push(wrapActivity(result,'update_or_create'));
            fetchNext = (result.length >= limitRecords) ? (fetchNext + result.length) : 0;
            startProcessingActivity();
        }
        function createdSyncQueryResult(error,rowsPack,fieldPack){
            if(error) return log('Error while fetching data, skipping !!','startProcessingActivity')
            let result = JSON.parse(JSON.stringify(rowsPack)); if(!result.length) log('No data','startProcessingActivity');
            else {
                log(`${result.length} records to mode create`); Activity.push(wrapActivity(result,'create'));
                if(updated) return processSync('updated');
                fetchNext = (result.length >= limitRecords) ? (fetchNext + result.length) : 0;
                startProcessingActivity();
            }
        }
        function updatedSyncQueryResult(error,rowsPack,fieldPack){
            if(error) return log('Error while fetching data, skipping !!','startProcessingActivity')
            let result = JSON.parse(JSON.stringify(rowsPack));
            log(`${result.length} records to mode update`); if(result.length) Activity.push(wrapActivity(result,'update'));
            startProcessingActivity();
        }
    </script>
    <script>
        function wrapActivity(data,mode){ return { table,mode,primary_key,data }; }
        function uploadActivityData(Activity){ loadUploadActivityWindow(Activity); }
    </script>
    <script>
        function destroyWindow(destroyWindow) { if(destroyWindow && !destroyWindow.isDestroyed()) destroyWindow.destroy(); }
        function loadExecuteQueryWindow(queries, success){
            let sendData = { mysqlParams,queries,parentWindowId:currentWindow.id,success };
            executeQueryWindow = new BrowserWindow(executeQueryWindowConf).on('closed',() => executeQueryWindow = null );
            if(executeQueryWindow){
                executeQueryWindow.loadURL(executeQueryWindowUrl);
                executeQueryWindow.webContents.on('did-finish-load',function(){ executeQueryWindow.webContents.send('data',sendData); });
            }
        }
        function loadUploadActivityWindow(activity){
            let sendData = { url,parentWindowId:currentWindow.id,activity,table };
            uploadActivityWindow = new BrowserWindow(uploadActivityWindowConf).on('closed',() => uploadActivityWindow = null );
            uploadActivityWindow.loadURL(uploadActivityWindowUrl);
            uploadActivityWindow.webContents.on('did-finish-load',function(){ uploadActivityWindow.webContents.send('data',sendData); });
        }
        function loadDateUpdateWindow(date){
            let sendData = { parentWindowId:currentWindow.id,date,id };
            updateDateWindow = new BrowserWindow(updateDateWindowConf).on('closed',() => updateDateWindow = null );
            updateDateWindow.loadURL(updateDateWindowUrl);
            updateDateWindow.webContents.on('did-finish-load',function(){ updateDateWindow.webContents.send('data',sendData); });
        }
        function loadImportActivityWindow(activity){
            let sendData = { parentWindowId:currentWindow.id,activity,mysqlParams,tblData:tblData[table] };
            importActivityWindow = new BrowserWindow(importActivityWindowConf).on('closed',() => importActivityWindow = null );
            importActivityWindow.loadURL(importActivityWindowUrl);
            importActivityWindow.webContents.on('did-finish-load',function(){ importActivityWindow.webContents.send('data',sendData); });
        }
        function loadDownloadActivityWindow(){
            let sendData = { url,parentWindowId:currentWindow.id,table };
            downloadActivityWindow = new BrowserWindow(downloadActivityWindowConf).on('closed',() => downloadActivityWindow = null );
            downloadActivityWindow.loadURL(downloadActivityWindowUrl);
            downloadActivityWindow.webContents.on('did-finish-load',function(){ downloadActivityWindow.webContents.send('data',sendData); });
        }
    </script>
    <script>
        function keepActivityDates(){
            log('Setting latest dates');
            _.forEach(Activity,(activity) => {
                let datetime = getDateTime();
                latestDates['sync'] = datetime;
                latestDates['record'] = _.max([getMaxOfDateField(activity.data,'CREATED_DATE'),latestDates['record']])
            });
        }
        function updateSyncDates(record){
            log('Updating times');
            latestDates['sync'] = getDateTime();
            if(record) latestDates['record'] = record;
            updateTableDatesWithServer();
        }
        function setRecordDateAndUpdate(dateObj){
            latestDates['record'] = dateObj[table];
            updateTableDatesWithServer();
        }
        function postUploadActivities(response){
            if(type === 'both' && !!response){
                let json = getJsonFromString(response);
                if(!_.isEmpty(json)) handleUploadResponseActivity(json);
            } else {
                keepActivityDates();
                updateTableDatesWithServer();
            }
        }
        function postDownloadActivities(response){
            if(!response || !response.length) { log('No Data'); return updateSyncDates(); }
            let activity = getJsonFromString(response);
            if(_.isEmpty(activity)) return updateSyncDates();
            loadImportActivityWindow(activity);
        }
        function postImportActivities(mDate,sqlStore,pkValues,exeStatus) {
            // POST ACTIONS HERE
            return updateSyncDates(mDate);
        }
        function handleUploadResponseActivity(activity){
            loadImportActivityWindow(activity);
        }
    </script>
    <script>
        function updateTableDatesWithServer(){ loadDateUpdateWindow(latestDates) }
    </script>
    <script>
        function writeTableDates() {
            if(latestDates.sync) updateTblData(table,'sync',latestDates.sync,function(){
                if(latestDates.record) updateTblData(table,'record',latestDates.record,repeatedProcess);
                else repeatedProcess();
            }); else if(latestDates.record) updateTblData(table,'record',latestDates.record,repeatedProcess);
            else repeatedProcess();
        }
        function updateTblData(table,property,value,callback){
            if(!_.has(tblData,table)) tblData[table] = new Object({});
            if(!_.has(tblData[table],property)) tblData[table][property] = null;
            tblData[table][property] = value; saveTblData(callback);
        }
        function saveTblData(callback){
            fs.writeFile(syncFile,JSON.stringify(tblData),function(error){
                if(!error) return (callback) ? callback.call() : null;
                doContinue = false; log('Error in saving sync info file!!');
            });
        }
    </script>
</head>
<body>
</body>
</html>