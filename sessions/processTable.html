<!DOCTYPE html>
<!--suppress ALL -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Processing Table :: </title>
    <script>
        const { ipcRenderer,remote } = require('electron'), { BrowserWindow, } = remote, currentWindow = remote.getCurrentWindow(),
            $ = require('jquery'), _ = require('lodash'), db = require('mysql'), path = require('path'), fs = require('fs'),
            limitRecords = 1750,
            executeQueryWindowConf = { width:300, height:300, show:false }, executeQueryWindowUrl = path.join(__dirname,'getQueryResult.html'),
            uploadActivityWindowConf = executeQueryWindowConf, uploadActivityWindowUrl = path.join(__dirname,'doUploadActivity.html'),
            updateDateWindowConf = executeQueryWindowConf, updateDateWindowUrl = path.join(__dirname,'updateDates.html')
            importActivityWindowConf = executeQueryWindowConf, importActivityWindowUrl = path.join(__dirname,'importActivity.html'),
            downloadActivityWindowConf = executeQueryWindowConf, downloadActivityWindowUrl = path.join(__dirname,'doDownloadActivity.html'),
            customImportWindowConf = executeQueryWindowConf, customImportWindowUrl = path.join(__dirname,'customImport.html')
        ;
        let table,type,tblData,sync,record,primary_key,fields,mysqlParams,mysql,oneTime,mode,url,id,queries,
            parentWindow, reCloseDelay = 2000, reCloseTimeOut = null, syncFile,fetchNext = { update_or_create:0,create:0,update:0 }, custom,
            executeQueryWindow, uploadActivityWindow, updateDateWindow, importActivityWindow, downloadActivityWindow, customImportWindow,
            Activity = [], latestDates = { sync:null,record:null }, modeDateFieldMap = { update:'MODIFIED_DATE',create:'CREATED_DATE' };
    </script>
    <script>
        ipcRenderer.on('config',function(event,dataObj){
            table = dataObj.table; tblData = dataObj.tblData; syncFile = dataObj.syncFile;
            parentWindow = BrowserWindow.fromId(dataObj.parentWindowId)
            type = tblData[table].type; sync = tblData[table].sync; record = tblData[table].record; delay = parseInt(tblData[table].delay); id = tblData[table].id; primary_key = tblData[table]['primary_key']; fields = tblData[table]["fields"];
            mysqlParams = dataObj.mysqlParams; setupMysqlConnection(); custom = dataObj.custom;
            $('title').append(table); oneTime = isOneTimeTable(); url = dataObj.url;
            initProcess()
        });

        ipcRenderer.on('log',function (event,text){ log(text) });
        ipcRenderer.on('query-result',function (event,fn,args){ destroyWindow(executeQueryWindow); window[fn].apply(window[fn],args); });
        ipcRenderer.on('failed-upload-activity',function (){ destroyWindow(uploadActivityWindow); log('Skipping..'); repeatedProcess(); });
        ipcRenderer.on('done-upload-activity',function (event,response){ destroyWindow(uploadActivityWindow); postUploadActivities(response); });
        ipcRenderer.on('update-date-success',function (event,response){ destroyWindow(updateDateWindow); writeTableDates(); });
        ipcRenderer.on('update-date-failed',function (){ log('Skipping..'); destroyWindow(updateDateWindow); repeatedProcess(); });
        ipcRenderer.on('failed-download-activity',function (){ destroyWindow(downloadActivityWindow); log('Skipping..'); completeProcessingTable(); });
        ipcRenderer.on('done-download-activity',function (event,response){ destroyWindow(downloadActivityWindow); postDownloadActivities(response); });
        ipcRenderer.on('done-import-activity',function (event,data){ destroyWindow(importActivityWindow); postImportActivities.apply(this,data); });
        ipcRenderer.on('done-custom-import',function (event,data){ destroyWindow(customImportWindow); postImportActivities.apply(this,data); });

        function send(channel,args){ parentWindow.send(channel,args); }
        function log(text,fn){ send('log',`${table}(${type}) :: ${text}`); if(fn) window[fn].call(); }
        function completeProcessingTable(){
            if(_.some([executeQueryWindow,uploadActivityWindow,updateDateWindow,importActivityWindow,downloadActivityWindow],(win) => !_.isNil(win))){
                clearTimeout(reCloseTimeOut); reCloseTimeOut = setTimeout(completeProcessingTable,reCloseDelay);
            } else { log('Finished..'); send('complete-process-table',[table,type]); } }
    </script>
    <script>
        function isOneTimeTable(){ return (!_.includes(fields,'CREATED_DATE') && !_.includes(fields,'MODIFIED_DATE')); }
        function isModOnlyTable(){ return (!_.includes(fields,'CREATED_DATE') && _.includes(fields,'MODIFIED_DATE')); }
        function isCreateOnlyTable(){ return (_.includes(fields,'CREATED_DATE') && !_.includes(fields,'MODIFIED_DATE')); }
        function isNormalTable(){ return (_.includes(fields,'CREATED_DATE') && _.includes(fields,'MODIFIED_DATE')); }
        function getDateTime(){
            let d = new Date();
            return [[d.getFullYear(),to2(d.getMonth()+1),to2(d.getDate())].join('-'),[to2(d.getHours()),to2(d.getMinutes()),to2(d.getSeconds())].join(':')].join(' ')
        }
        function to2(t){ return _.padStart(t,2,0)}
        function getMaxOfDateField(collection,field){
            let dateObject = _.mapKeys(_.map(collection,field),dText => new Date(dText).getTime());
            return _.get(dateObject,_.max(_.keys(dateObject)))
        }
        function isJsonString(string){
            try{ JSON.parse(string) } catch(e) { return false; }
            return true;
        }
        function getJsonFromString(input) {
            return (_.isString(input) && isJsonString(input)) ? JSON.parse(input) : ( _.isPlainObject(input) ? input : [])
        }
    </script>
    <script>
        function setupMysqlConnection(){ mysql = db.createConnection(mysqlParams); }
        function getSyncCreatedQuery(limit){ return mysql.format("SELECT * FROM ?? WHERE ?? > ? ORDER BY ?? ASC LIMIT ?,?",[table,'CREATED_DATE',created,'CREATED_DATE',limit,limitRecords]); }
        function getSyncUpdatedQuery(limit){ return mysql.format("SELECT * FROM ?? WHERE ?? > ? AND ?? <= ? ORDER BY ?? ASC LIMIT ?,?",[table,'MODIFIED_DATE',updated,'CREATED_DATE',created,'MODIFIED_DATE',limit,limitRecords]); }
        function getSyncAllQuery(limit){ return mysql.format("SELECT * FROM ?? LIMIT ?,?",[table,limit,limitRecords]); }
        function getUpSync(limit){ return mysql.format("SELECT * FROM ?? LIMIT ?,?",[table,limit,limitRecords]); }

        function update_or_create_RecordQuery(){ return mysql.format("SELECT * FROM ??",[table]) }
        function create_RecordQuery(datetime){ return mysql.format("SELECT * FROM ?? WHERE ?? > ? ORDER BY ?? ASC",[table,'CREATED_DATE',datetime,'CREATED_DATE']) }
        function update_RecordQuery(record,sync){ return mysql.format("SELECT * FROM ?? WHERE ?? <= ? AND ?? > ? ORDER BY ?? ASC",[table,'CREATED_DATE',record,'MODIFIED_DATE',sync,'MODIFIED_DATE']) }
        function latest_modified_RecordQuery(datetime){ return mysql.format("SELECT * FROM ?? WHERE ?? > ? ORDER BY ?? ASC",[table,'MODIFIED_DATE',datetime,'MODIFIED_DATE']) }

        function getLimitAppliedQueries(qryObj){
            let modQryObj = {};
            _.forEach(qryObj,(query,mode) => {
                let lQry = [query,'LIMIT ?,?'].join(' ');
                modQryObj[mode] = mysql.format(lQry,[fetchNext[mode],limitRecords])
            })
            return modQryObj;
        }
    </script>
    <script>
        function initProcess(){
            Activity = []; log('Processing');
            window[type+'SyncInit'].call();
        }
        function upSyncInit(){
            queries = {};
            if(!sync && !record) queries['create'] = update_or_create_RecordQuery();
            else if(sync && (oneTime || delay === 0 || !record)) queries['update_or_create'] = update_or_create_RecordQuery();
            else if(sync && isModOnlyTable()) queries['update_or_create'] = latest_modified_RecordQuery(sync);
            else if(sync && record) {
                queries['create'] = create_RecordQuery(record);
                queries['update'] = update_RecordQuery(record,sync);
            }
            initExecutingQueries(queries);
        }
        function bothSyncInit(){
            return upSyncInit();
        }
        function downSyncInit(){
            loadDownloadActivityWindow();
            // let fakeActivity = [{ table:'importsales',mode:'create',primary_key:[],data:[{"BILLNO":"HJ","DOCDATE":"2019-07-19 15:34:18","ACCCODE":"HJ","ITEMCODE":"HJ","UNITCODE":"UI","PARTCODE":"JIO","QTY":1.0000000000,"RATE":0.0000000000,"DISCOUNT":0.0000000000,"COCODE":"01","BRCODE":"HO","FYCODE":"1920"},{"BILLNO":"HJj","DOCDATE":"2019-07-19 15:34:18","ACCCODE":"HJj","ITEMCODE":"HJjj","UNITCODE":"UItt","PARTCODE":"JIOjjjj","QTY":2.0000000000,"RATE":0.0000000000,"DISCOUNT":0.0000000000,"COCODE":"01","BRCODE":"PO","FYCODE":"1920"}]}];
            // loadCustomImportWindow(fakeActivity);
        }
        function handleQueryResults(result){
            for(mode in result){
                let data = result[mode];
                if(data === false) { console.log(mode,queries[mode],fetchNext); return log(mode + ' :: Error!!');  }
                else if(data.length === 0) log(mode + ' :: No data');
                else {
                    log(mode + ' :: Have data');
                    fetchNext[mode] = (data.length >= limitRecords) ? (fetchNext[mode] + data.length) : 0
                    Activity.push(wrapActivity(data,mode));
                }
            }
            startProcessingActivity()
        }
        function startProcessingActivity(){
            if(!Activity || _.isEmpty(Activity)) return completeProcessingTable();
            log(`${Activity.length} activities found!!`);
            uploadActivityData(Activity);
        }
        function initExecutingQueries(eQueries) {
            if(Object.keys(eQueries).length > 0) return loadExecuteQueryWindow(eQueries,'handleQueryResults');
            else return completeProcessingTable();
        }
        function repeatedProcess() {
            if(type === 'down') return completeProcessingTable();
            Activity = []; log('Check for further records..');
            rQueries = {};
            _.forEach(queries,(query,mode) => {
                if(fetchNext[mode] !== 0) rQueries[mode] = query;
            });
            initExecutingQueries(rQueries);
        }
    </script>
    <script>
        function oneTimeSyncQueryResult(error,rowsPack,fieldPack) {
            if(error) return log('Error while fetching data, skipping !!','startProcessingActivity')
            let result = JSON.parse(JSON.stringify(rowsPack)); if(!result.length) return log('No data','startProcessingActivity');
            log(`${result.length} records to mode update_or_create`); Activity.push(wrapActivity(result,'update_or_create'));
            fetchNext = (result.length >= limitRecords) ? (fetchNext + result.length) : 0;
            startProcessingActivity();
        }
        function createdSyncQueryResult(error,rowsPack,fieldPack){
            if(error) return log('Error while fetching data, skipping !!','startProcessingActivity')
            let result = JSON.parse(JSON.stringify(rowsPack)); if(!result.length) log('No data','startProcessingActivity');
            else {
                log(`${result.length} records to mode create`); Activity.push(wrapActivity(result,'create'));
                if(updated) return processSync('updated');
                fetchNext = (result.length >= limitRecords) ? (fetchNext + result.length) : 0;
                startProcessingActivity();
            }
        }
        function updatedSyncQueryResult(error,rowsPack,fieldPack){
            if(error) return log('Error while fetching data, skipping !!','startProcessingActivity')
            let result = JSON.parse(JSON.stringify(rowsPack));
            log(`${result.length} records to mode update`); if(result.length) Activity.push(wrapActivity(result,'update'));
            startProcessingActivity();
        }
    </script>
    <script>
        function wrapActivity(data,mode){ return { table,mode,primary_key,data }; }
        function uploadActivityData(Activity){ loadUploadActivityWindow(Activity); }
    </script>
    <script>
        function destroyWindow(destroyWindow) { if(destroyWindow && !destroyWindow.isDestroyed()) destroyWindow.destroy(); }
        function loadExecuteQueryWindow(eQueries, success){
            let lQueries = getLimitAppliedQueries(eQueries);
            let sendData = { mysqlParams,queries:lQueries,parentWindowId:currentWindow.id,success };
            executeQueryWindow = new BrowserWindow(executeQueryWindowConf).on('closed',() => executeQueryWindow = null );
            if(executeQueryWindow){
                executeQueryWindow.loadURL(executeQueryWindowUrl);
                executeQueryWindow.webContents.on('did-finish-load',function(){ executeQueryWindow.webContents.send('data',sendData); });
            }
        }
        function loadUploadActivityWindow(activity){
            let sendData = { url,parentWindowId:currentWindow.id,activity,table };
            uploadActivityWindow = new BrowserWindow(uploadActivityWindowConf).on('closed',() => uploadActivityWindow = null );
            uploadActivityWindow.loadURL(uploadActivityWindowUrl);
            uploadActivityWindow.webContents.on('did-finish-load',function(){ uploadActivityWindow.webContents.send('data',sendData); });
        }
        function loadDateUpdateWindow(date){
            let sendData = { parentWindowId:currentWindow.id,date,id };
            updateDateWindow = new BrowserWindow(updateDateWindowConf).on('closed',() => updateDateWindow = null );
            updateDateWindow.loadURL(updateDateWindowUrl);
            updateDateWindow.webContents.on('did-finish-load',function(){ updateDateWindow.webContents.send('data',sendData); });
        }
        function loadImportActivityWindow(activity){
            let sendData = { parentWindowId:currentWindow.id,activity,mysqlParams,tblData:tblData[table] };
            importActivityWindow = new BrowserWindow(importActivityWindowConf).on('closed',() => importActivityWindow = null );
            importActivityWindow.loadURL(importActivityWindowUrl);
            importActivityWindow.webContents.on('did-finish-load',function(){ importActivityWindow.webContents.send('data',sendData); });
        }
        function loadDownloadActivityWindow(){
            let sendData = { url,parentWindowId:currentWindow.id,table };
            downloadActivityWindow = new BrowserWindow(downloadActivityWindowConf).on('closed',() => downloadActivityWindow = null );
            downloadActivityWindow.loadURL(downloadActivityWindowUrl);
            downloadActivityWindow.webContents.on('did-finish-load',function(){ downloadActivityWindow.webContents.send('data',sendData); });
        }
        function loadCustomImportWindow(Activity){
            let sendData = { table,mysqlParams,Activity,parentWindowId:currentWindow.id,tblData:tblData[table] };
            customImportWindow = new BrowserWindow(customImportWindowConf).on('closed',() => customImportWindow = null );
            customImportWindow.loadURL(customImportWindowUrl);
            customImportWindow.webContents.on('did-finish-load',function(){ customImportWindow.webContents.send('data',sendData); });
        }
    </script>
    <script>
        function keepActivityDates(){
            log('Setting latest dates');
            _.forEach(Activity,(activity) => {
                let datetime = getDateTime();
                latestDates['sync'] = datetime;
                latestDates['record'] = _.max([getMaxOfDateField(activity.data,'CREATED_DATE'),latestDates['record']])
            });
        }
        function updateSyncDates(record){
            log('Updating times');
            latestDates['sync'] = getDateTime();
            if(record) latestDates['record'] = record;
            updateTableDatesWithServer();
        }
        function setRecordDateAndUpdate(dateObj){
            latestDates['record'] = dateObj[table];
            updateTableDatesWithServer();
        }
        function postUploadActivities(response){
            if(type === 'both' && !!response){
                let json = getJsonFromString(response);
                if(!_.isEmpty(json)) return handleUploadResponseActivity(json);
            }
            keepActivityDates();
            updateTableDatesWithServer();
        }
        function postDownloadActivities(response){
            if(!response || !response.length) { log('No Data'); return repeatedProcess(); }
            let activity = getJsonFromString(response);
            if(_.isEmpty(activity)) return repeatedProcess();
            latestDates['sync'] = activity[0].datetime;
            proceedImportingActivity(activity)
        }
        function proceedImportingActivity(activity){
            if(custom) loadCustomImportWindow(activity)
            else loadImportActivityWindow(activity);
        }
        function postImportActivities(mDate,sqlStore,pkValues,exeStatus,exeRecords) {
            return mDate ? setRecordDateAndUpdate(_.fromPairs([table],[mDate])) : repeatedProcess();
        }
        function handleUploadResponseActivity(activity){
            proceedImportingActivity(activity);
        }
    </script>
    <script>
        function updateTableDatesWithServer(){ loadDateUpdateWindow(latestDates) }
    </script>
    <script>
        function writeTableDates() {
            if(latestDates.sync) updateTblData(table,'sync',latestDates.sync,function(){
                if(latestDates.record) updateTblData(table,'record',latestDates.record,repeatedProcess);
                else repeatedProcess();
            }); else if(latestDates.record) updateTblData(table,'record',latestDates.record,repeatedProcess);
            else repeatedProcess();
        }
        function updateTblData(table,property,value,callback){
            if(!_.has(tblData,table)) tblData[table] = new Object({});
            if(!_.has(tblData[table],property)) tblData[table][property] = null;
            tblData[table][property] = value; saveTblData(callback);
        }
        function saveTblData(callback){
            fs.writeFile(syncFile,JSON.stringify(tblData),function(error){
                if(!error) return (callback) ? callback.call() : null;
                doContinue = false; log('Error in saving sync info file!!');
            });
        }
    </script>
</head>
<body>
</body>
</html>